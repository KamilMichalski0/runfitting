const WeeklyPlanDeliveryService = require('../services/weekly-plan-delivery.service');
const TrainingPlan = require('../models/training-plan.model');
const AppError = require('../utils/app-error');
const { logError, logInfo, logWarning } = require('../utils/logger');
const aiJobService = require('../services/ai-job.service');
const sseNotificationService = require('../services/sse-notification.service');

/**
 * Kontroler odpowiedzialny za zarzƒÖdzanie harmonogramami dostarczania plan√≥w tygodniowych
 */
function WeeklyScheduleController() {
  this.weeklyPlanDeliveryService = new WeeklyPlanDeliveryService();
  
  // Bind methods to this instance
  this.createSchedule = this.createSchedule.bind(this);
  this.getSchedule = this.getSchedule.bind(this);
  this.updateSchedule = this.updateSchedule.bind(this);
  this.pauseSchedule = this.pauseSchedule.bind(this);
  this.resumeSchedule = this.resumeSchedule.bind(this);
  this.deactivateSchedule = this.deactivateSchedule.bind(this);
  this.updateProgress = this.updateProgress.bind(this);
  this.manualDelivery = this.manualDelivery.bind(this);
  this.getHistory = this.getHistory.bind(this);
  this.getAllWeeklyPlans = this.getAllWeeklyPlans.bind(this);
  this.generateNewPlan = this.generateNewPlan.bind(this);
  this.deleteAllPlans = this.deleteAllPlans.bind(this);
  this.getJobStatus = this.getJobStatus.bind(this);
  this.getNotifications = this.getNotifications.bind(this);
}

WeeklyScheduleController.prototype.createSchedule = async function(req, res, next) {
  try {
    const userId = req.user.sub;
    const scheduleData = req.body;

    // Szczeg√≥≈Çowe logowanie na poczƒÖtku
    logInfo(`Creating schedule for user ${userId}`, {
      hasUserProfile: !!scheduleData.userProfile,
      hasDniTreningowe: !!scheduleData.userProfile?.dniTreningowe,
      hasTrainingDays: !!scheduleData.userProfile?.trainingDays,
      userProfileKeys: Object.keys(scheduleData.userProfile || {}),
      dniTreningoweValue: scheduleData.userProfile?.dniTreningowe,
      trainingDaysValue: scheduleData.userProfile?.trainingDays
    });

    if (!scheduleData.userProfile) {
      logError(`Missing userProfile in request for user ${userId}`);
      return res.status(400).json({
        error: 'Dane profilu u≈ºytkownika sƒÖ wymagane'
      });
    }

    // Walidacja dni treningowych - to jest krytyczne dla generowania plan√≥w
    if (!scheduleData.userProfile?.dniTreningowe && !scheduleData.userProfile?.trainingDays) {
      logWarning(`Missing training days in userProfile for user ${userId}`, {
        userProfile: scheduleData.userProfile,
        availableKeys: Object.keys(scheduleData.userProfile || {})
      });
      
      // Zwr√≥ƒá b≈ÇƒÖd walidacji je≈õli nie ma dni treningowych
      return res.status(400).json({
        error: 'Dni treningowe sƒÖ wymagane do utworzenia harmonogramu. Proszƒô okre≈õliƒá dniTreningowe lub trainingDays w profilu u≈ºytkownika.',
        details: {
          missingFields: ['dniTreningowe', 'trainingDays'],
          receivedFields: Object.keys(scheduleData.userProfile || {})
        }
      });
    }

    // Normalizacja danych - upewnij siƒô ≈ºe mamy dni treningowe w odpowiednim formacie
    if (scheduleData.userProfile.trainingDays && !scheduleData.userProfile.dniTreningowe) {
      scheduleData.userProfile.dniTreningowe = scheduleData.userProfile.trainingDays;
      logInfo(`Normalized trainingDays to dniTreningowe for user ${userId}`, {
        trainingDays: scheduleData.userProfile.trainingDays,
        normalizedTo: scheduleData.userProfile.dniTreningowe
      });
    }

    // Walidacja formatu dni treningowych
    const dniTreningowe = scheduleData.userProfile.dniTreningowe || scheduleData.userProfile.trainingDays;
    if (!Array.isArray(dniTreningowe) || dniTreningowe.length === 0) {
      logError(`Invalid training days format for user ${userId}`, {
        dniTreningowe,
        type: typeof dniTreningowe,
        isArray: Array.isArray(dniTreningowe)
      });
      return res.status(400).json({
        error: 'Dni treningowe muszƒÖ byƒá niepustƒÖ tablicƒÖ',
        details: {
          received: dniTreningowe,
          expected: 'Array with at least one training day'
        }
      });
    }

    logInfo(`Validated training days for user ${userId}`, {
      dniTreningowe: dniTreningowe,
      count: dniTreningowe.length
    });

    const schedule = await this.weeklyPlanDeliveryService.createSchedule(userId, scheduleData);

    res.status(201).json({
      status: 'success',
      data: {
        schedule
      }
    });
  } catch (error) {
    logError('B≈ÇƒÖd tworzenia harmonogramu', error);
    
    if (error instanceof AppError) {
      return res.status(error.statusCode).json({
        error: error.message
      });
    }
    
    return res.status(500).json({
      error: 'WystƒÖpi≈Ç b≈ÇƒÖd podczas tworzenia harmonogramu'
    });
  }
};

WeeklyScheduleController.prototype.getSchedule = async function(req, res, next) {
  try {
    const userId = req.user.sub;
    
    console.log(`üîç [SCHEDULE-CONTROLLER] Getting schedule for user: ${userId}`);
    
    // Pobierz harmonogram - je≈õli nie ma, stw√≥rz go
    const schedule = await this.weeklyPlanDeliveryService.getUserScheduleWithFallback(userId);
    
    // WyciƒÖgnij aktualny plan z recentPlans
    let currentPlan = null;
    if (schedule && schedule.recentPlans && schedule.recentPlans.length > 0) {
      const latestPlan = schedule.recentPlans[0];
      if (latestPlan && latestPlan.planId) {
        currentPlan = latestPlan.planId;
        console.log(`üîç [SCHEDULE-CONTROLLER] PLAN SOURCE: From harmonogram.recentPlans[0]`);
        console.log(`üîç [SCHEDULE-CONTROLLER] Plan ID: ${latestPlan.planId._id}, Week: ${latestPlan.weekNumber}`);
      }
    }
    
    if (!currentPlan) {
      console.log(`üîç [SCHEDULE-CONTROLLER] PLAN SOURCE: Brak planu w harmonogramie${schedule ? ' (harmonogram istnieje)' : ''}`);
    }

    res.json({
      status: 'success',
      data: {
        schedule,
        currentPlan,
        pendingReview: null,
        upcomingDelivery: schedule?.nextDeliveryDate || null,
        fallbackCreated: schedule._id === undefined ? false : schedule._id.toString().includes('fallback')
      }
    });
  } catch (error) {
    console.log(`‚ùå [SCHEDULE-CONTROLLER] B≈ÇƒÖd pobierania harmonogramu:`, error.message);
    logError('B≈ÇƒÖd pobierania harmonogramu', error);
    
    if (error instanceof AppError) {
      return res.status(error.statusCode).json({
        error: error.message,
        needsSetup: error.statusCode === 400 && error.message.includes('Brak danych formularza')
      });
    }
    
    return res.status(500).json({
      error: 'WystƒÖpi≈Ç b≈ÇƒÖd podczas pobierania harmonogramu'
    });
  }
};

WeeklyScheduleController.prototype.updateSchedule = async function(req, res, next) {
  try {
    const userId = req.user.sub;
    const updateData = req.body;

    const schedule = await this.weeklyPlanDeliveryService.updateSchedule(userId, updateData);

    res.json({
      status: 'success',
      data: {
        schedule
      }
    });
  } catch (error) {
    logError('B≈ÇƒÖd aktualizacji harmonogramu', error);
    
    if (error instanceof AppError) {
      return res.status(error.statusCode).json({
        error: error.message
      });
    }
    
    return res.status(500).json({
      error: 'WystƒÖpi≈Ç b≈ÇƒÖd podczas aktualizacji harmonogramu'
    });
  }
};

WeeklyScheduleController.prototype.pauseSchedule = async function(req, res, next) {
  try {
    const userId = req.user.sub;
    const { pauseUntil } = req.body;

    const schedule = await this.weeklyPlanDeliveryService.pauseSchedule(userId, pauseUntil);

    res.json({
      status: 'success',
      data: {
        schedule
      }
    });
  } catch (error) {
    logError('B≈ÇƒÖd wstrzymania harmonogramu', error);
    
    if (error instanceof AppError) {
      return res.status(error.statusCode).json({
        error: error.message
      });
    }
    
    return res.status(500).json({
      error: 'WystƒÖpi≈Ç b≈ÇƒÖd podczas wstrzymania harmonogramu'
    });
  }
};

WeeklyScheduleController.prototype.resumeSchedule = async function(req, res, next) {
  try {
    const userId = req.user.sub;

    const schedule = await this.weeklyPlanDeliveryService.resumeSchedule(userId);

    res.json({
      status: 'success',
      data: {
        schedule
      }
    });
  } catch (error) {
    logError('B≈ÇƒÖd wznawiania harmonogramu', error);
    
    if (error instanceof AppError) {
      return res.status(error.statusCode).json({
        error: error.message
      });
    }
    
    return res.status(500).json({
      error: 'WystƒÖpi≈Ç b≈ÇƒÖd podczas wznawiania harmonogramu'
    });
  }
};

WeeklyScheduleController.prototype.deactivateSchedule = async function(req, res, next) {
  try {
    const userId = req.user.sub;

    const schedule = await this.weeklyPlanDeliveryService.deactivateSchedule(userId);

    res.json({
      status: 'success',
      data: {
        schedule
      }
    });
  } catch (error) {
    logError('B≈ÇƒÖd deaktywacji harmonogramu', error);
    
    if (error instanceof AppError) {
      return res.status(error.statusCode).json({
        error: error.message
      });
    }
    
    return res.status(500).json({
      error: 'WystƒÖpi≈Ç b≈ÇƒÖd podczas deaktywacji harmonogramu'
    });
  }
};

WeeklyScheduleController.prototype.updateProgress = async function(req, res, next) {
  try {
    const userId = req.user.sub;
    const { planId, weekNumber, progressData } = req.body;

    logInfo(`Otrzymano ≈ºƒÖdanie aktualizacji postƒôpu dla u≈ºytkownika ${userId}: planId=${planId}, weekNumber=${weekNumber}`);

    // U≈ºyj planId je≈õli dostƒôpne, w przeciwnym razie weekNumber
    const planIdentifier = planId || weekNumber;
    
    if (!planIdentifier) {
      return res.status(400).json({
        status: 'error',
        error: 'Wymagany jest planId lub weekNumber'
      });
    }

    if (!progressData) {
      return res.status(400).json({
        status: 'error',
        error: 'Dane postƒôpu sƒÖ wymagane'
      });
    }

    const result = await this.weeklyPlanDeliveryService.updateWeeklyProgress(
      userId,
      planIdentifier,
      progressData
    );

    let jobId = null;
    // Je≈õli zaktualizowano postƒôp, wygeneruj nowy plan w kolejce Redis
    if (result.scheduleUpdated || result.updatedPlan) {
      try {
        // Pobierz harmonogram dla kolejki (z fallbackiem)
        const schedule = await this.weeklyPlanDeliveryService.getUserScheduleWithFallback(userId);
        
        jobId = await aiJobService.queueWeeklyPlanGeneration(
          userId,
          schedule._id,
          { resetToWeekOne: false },
          { priority: 2 } // Wy≈ºszy priorytet dla generowania po ocenie
        );
        
        logInfo(`Dodano zadanie generowania kolejnego planu do kolejki: ${jobId}`);
      } catch (queueError) {
        logError('B≈ÇƒÖd podczas dodawania zadania do kolejki:', queueError);
        // Nie blokuj odpowiedzi je≈õli kolejka nie dzia≈Ça
      }
    }

    // Przygotuj odpowied≈∫ w zale≈ºno≈õci od tego co zosta≈Ço zaktualizowane
    const responseData = {
      message: result.message || 'Postƒôp zosta≈Ç zaktualizowany',
      updated: {
        schedule: !!result.scheduleUpdated,
        plan: !!result.updatedPlan
      }
    };

    // Dodaj informacjƒô o kolejce Redis
    if (jobId) {
      responseData.planGenerationQueued = true;
      responseData.jobId = jobId;
      responseData.statusUrl = `/api/plans/status/${jobId}`;
      responseData.message = 'Postƒôp zapisany, nowy plan jest generowany w kolejce Redis';
    }

    // Zachowaj starƒÖ logikƒô dla przypadk√≥w gdy plan jest od razu dostƒôpny (nie powinno siƒô zdarzyƒá)
    if (result.newPlan) {
      responseData.newPlan = result.newPlan;
      responseData.message = 'Postƒôp zapisany i wygenerowano nowy plan';
    }

    // Dodaj informacje o harmonogramie je≈õli istnieje
    if (result.schedule) {
      responseData.schedule = result.schedule;
    }

    // Dodaj informacje o zaktualizowanym planie
    if (result.updatedPlan) {
      responseData.updatedPlan = result.updatedPlan;
    }

    res.json({
      status: 'success',
      data: responseData
    });

    logInfo(`Pomy≈õlnie zaktualizowano postƒôp dla u≈ºytkownika ${userId}: ${result.message}`);

  } catch (error) {
    logError('B≈ÇƒÖd aktualizacji postƒôpu', error);
    
    if (error instanceof AppError) {
      return res.status(error.statusCode).json({
        status: 'error',
        error: error.message
      });
    }
    
    return res.status(500).json({
      status: 'error',
      error: 'WystƒÖpi≈Ç b≈ÇƒÖd podczas aktualizacji postƒôpu'
    });
  }
};

WeeklyScheduleController.prototype.manualDelivery = async function(req, res, next) {
  try {
    const userId = req.user.sub;
    const { resetWeekNumber = false } = req.body; // Opcja resetowania numeru tygodnia

    logInfo(`Manual delivery requested for user ${userId} with resetWeekNumber=${resetWeekNumber}`);

    let schedule;
    let expectedWeekNumber;
    
    if (resetWeekNumber) {
      logInfo('Using mock schedule for new plan generation (starting from week 1)');
      expectedWeekNumber = 1;
      
      // Try to get user profile from existing schedule or saved form data
      let userProfile = {
        name: 'User',
        age: 30,
        experienceLevel: 'beginner',
        mainGoal: 'start_running',
        daysPerWeek: 3
      };
      
      // ZAWSZE pr√≥buj pobraƒá dane z najnowszego formularza
      try {
        const TrainingFormSubmission = require('../models/running-form.model');
        // Znajd≈∫ najnowszy formularz z wype≈Çnionymi dniami treningowymi
        const latestForm = await TrainingFormSubmission.findOne({ 
          userId,
          dniTreningowe: { $exists: true, $ne: [], $ne: null }
        }).sort({ createdAt: -1 });
        
        if (latestForm) {
          const formData = latestForm.toObject();
          logInfo(`=== DEBUG: Pobrano formularz dla u≈ºytkownika ${userId} (manual delivery) ===`, {
            formId: latestForm._id,
            createdAt: latestForm.createdAt,
            dniTreningowe: formData.dniTreningowe,
            allFormFields: Object.keys(formData),
            imieNazwisko: formData.imieNazwisko,
            poziomZaawansowania: formData.poziomZaawansowania
          });
          
          const trainingPlanController = require('./training-plan.controller');
          userProfile = trainingPlanController.mapFormToUserProfile(formData);
          logInfo(`Using profile from latest form data for user ${userId}: ${userProfile.name}, dni: ${JSON.stringify(userProfile.dniTreningowe)}`);
        } else {
          // Fallback: spr√≥buj istniejƒÖcy harmonogram tylko gdy brak formularza
          try {
            const existingSchedule = await this.weeklyPlanDeliveryService.getUserSchedule(userId);
            if (existingSchedule && existingSchedule.userProfile) {
              userProfile = { ...userProfile, ...existingSchedule.userProfile };
              logInfo(`No form found - using existing schedule profile for user ${userId}`);
            } else {
              logInfo('No saved form data and no existing schedule found');
            }
          } catch (scheduleError) {
            logError('Error fetching existing schedule:', scheduleError);
            logInfo('Using default profile due to schedule fetch error');
          }
        }
      } catch (formError) {
        logError('Error fetching form data:', formError);
        logInfo('Using default profile due to form fetch error');
      }
      
      // Stw√≥rz tymczasowy obiekt schedule dla nowego planu (od tygodnia 1)
      schedule = {
        userId: userId,
        userProfile: userProfile,
        progressTracking: {
          weekNumber: 1,
          currentPhase: 'base',
          totalWeeksDelivered: 0,
          lastWeeklyDistance: 0,
          progressionRate: 1.0
        },
        longTermGoal: 'general_fitness',
        deliveryFrequency: 'weekly',
        adaptationSettings: {
          autoAdjust: true
        },
        recentPlans: [],
        _id: 'mock-schedule-id',
        
        // Mockowe metody dla test√≥w
        updateProgress: function() {
          // Don't update for new plans - let generateWeeklyPlan handle it
        },
        save: async function() {
          return Promise.resolve(this);
        }
      };
    } else {
      logInfo('Using real schedule for week progression');
      // Pobierz prawdziwy harmonogram u≈ºytkownika (dla kolejnego tygodnia)
      schedule = await this.weeklyPlanDeliveryService.getUserSchedule(userId);
      
      if (!schedule) {
        return res.status(404).json({
          error: 'Nie znaleziono harmonogramu u≈ºytkownika. U≈ºyj resetWeekNumber=true aby utworzyƒá nowy plan.'
        });
      }
      
      const currentWeek = schedule.progressTracking?.weekNumber || 1;
      expectedWeekNumber = currentWeek + 1;
      logInfo(`Using real schedule - progressing from week ${currentWeek} to week ${expectedWeekNumber}`);
    }

    // Dodaj zadanie do kolejki Redis zamiast synchronicznego generowania
    const planData = {
      resetToWeekOne: resetWeekNumber,
      mockSchedule: resetWeekNumber ? schedule : null
    };
    
    const jobId = await aiJobService.queueWeeklyPlanGeneration(
      userId,
      resetWeekNumber ? null : schedule._id,
      planData,
      { priority: 3 } // Najwy≈ºszy priorytet dla rƒôcznego generowania
    );

    res.json({
      status: 'queued',
      data: {
        jobId,
        expectedWeekNumber,
        isNewPlan: resetWeekNumber,
        statusUrl: `/api/plans/status/${jobId}`,
        message: resetWeekNumber 
          ? `Nowy plan jest generowany w kolejce od tygodnia ${expectedWeekNumber}`
          : `Plan progresji jest generowany w kolejce dla tygodnia ${expectedWeekNumber}`
      }
    });
  } catch (error) {
    logError('B≈ÇƒÖd rƒôcznego generowania planu', error);
    
    if (error instanceof AppError) {
      return res.status(error.statusCode).json({
        error: error.message
      });
    }
    
    return res.status(500).json({
      error: 'WystƒÖpi≈Ç b≈ÇƒÖd podczas rƒôcznego generowania planu'
    });
  }
};

WeeklyScheduleController.prototype.getHistory = async function(req, res, next) {
  try {
    const userId = req.user.sub;
    const { limit, offset } = req.query;

    // Pobierz plany bezpo≈õrednio z TrainingPlan tabeli
    const plans = await TrainingPlan.find({
      userId: userId,
      planType: 'weekly'
    })
    .sort({ createdAt: -1 })
    .limit(parseInt(limit) || 10)
    .skip(parseInt(offset) || 0)
    .select('id weekNumber metadata createdAt plan_weeks userId planType');

    logInfo(`Found ${plans.length} weekly plans for user ${userId}`);

    res.json({
      status: 'success',
      data: {
        plans: plans,
        pagination: {
          limit: parseInt(limit) || 10,
          offset: parseInt(offset) || 0,
          total: plans.length
        }
      }
    });
  } catch (error) {
    logError('B≈ÇƒÖd pobierania historii', error);
    
    if (error instanceof AppError) {
      return res.status(error.statusCode).json({
        error: error.message
      });
    }
    
    return res.status(500).json({
      error: 'WystƒÖpi≈Ç b≈ÇƒÖd podczas pobierania historii'
    });
  }
};

WeeklyScheduleController.prototype.getAllWeeklyPlans = async function(req, res, next) {
  try {
    const userId = req.user.sub;
    
    // Pobierz plany bezpo≈õrednio z TrainingPlan tabeli
    const plans = await TrainingPlan.find({
      userId: userId,
      planType: 'weekly'
    })
    .sort({ createdAt: -1 })
    .select('id weekNumber metadata createdAt plan_weeks userId planType');

    logInfo(`Found ${plans.length} weekly plans for getAllWeeklyPlans for user ${userId}`);

    // Przekszta≈Çƒá plany do formatu oczekiwanego przez frontend
    const weeklyPlans = plans.map((plan, index) => ({
      weekNumber: plan.weekNumber || (index + 1),
      deliveryDate: plan.createdAt.toISOString(),
      plan: plan
    }));

    // Spr√≥buj pobraƒá harmonogram dla metadanych (opcjonalne)
    let schedule = null;
    let totalWeeks = plans.length;
    let currentWeek = plans.length > 0 ? Math.max(...plans.map(p => p.weekNumber || 1)) : 1;
    
    try {
      schedule = await this.weeklyPlanDeliveryService.getUserSchedule(userId);
      if (schedule) {
        // Use longTermGoal.remainingWeeks if available for total program duration
        if (schedule.longTermGoal && schedule.longTermGoal.remainingWeeks) {
          totalWeeks = schedule.longTermGoal.remainingWeeks;
        } else {
          // Default to 12 weeks if no specific goal is set
          totalWeeks = 12;
        }
        
        if (schedule.progressTracking) {
          currentWeek = schedule.progressTracking.weekNumber || currentWeek;
        }
      }
    } catch (scheduleError) {
      logInfo(`No schedule found for user ${userId}, using default 12 weeks program`);
      totalWeeks = 12; // Default to 12 weeks program
    }

    res.json({
      status: 'success',
      data: {
        totalWeeks: totalWeeks,
        currentWeek: currentWeek,
        plans: weeklyPlans
      }
    });
  } catch (error) {
    logError('B≈ÇƒÖd pobierania plan√≥w tygodniowych', error);
    return res.status(500).json({
      error: 'WystƒÖpi≈Ç b≈ÇƒÖd podczas pobierania plan√≥w tygodniowych'
    });
  }
};

/**
 * Waliduje i czy≈õci recentPlans, usuwajƒÖc stale referencje
 * @param {Object} schedule - Harmonogram u≈ºytkownika
 * @param {string} userId - ID u≈ºytkownika
 * @returns {Array} Zwalidowane plany
 */
WeeklyScheduleController.prototype._validateAndCleanupPlans = async function(schedule, userId) {
  const validatedPlans = [];
  const staleReferences = [];

  // Sprawd≈∫ ka≈ºdy plan w recentPlans
  for (const planRef of schedule.recentPlans || []) {
    try {
      // Sprawd≈∫ czy plan istnieje i nale≈ºy do u≈ºytkownika
      const plan = await TrainingPlan.findOne({
        _id: planRef.planId,
        userId: userId,
        planType: 'weekly'
      }).lean();

      if (plan) {
        // Plan istnieje - dodaj do validatedPlans
        validatedPlans.push({
          weekNumber: planRef.weekNumber,
          deliveryDate: planRef.deliveryDate,
          plan: plan
        });
      } else {
        // Plan nie istnieje - zaznacz jako stale reference
        staleReferences.push(planRef);
        logWarning(`Znaleziono stale reference do planu ${planRef.planId} dla u≈ºytkownika ${userId}`);
      }
    } catch (error) {
      // B≈ÇƒÖd podczas sprawdzania planu - zaznacz jako stale reference
      staleReferences.push(planRef);
      logError(`B≈ÇƒÖd podczas walidacji planu ${planRef.planId}`, error);
    }
  }

  // Je≈õli znaleziono stale referencje, usu≈Ñ je z harmonogramu
  if (staleReferences.length > 0) {
    await this._cleanupStaleReferences(schedule, staleReferences, userId);
  }

  return validatedPlans;
};

/**
 * Usuwa stale referencje z harmonogramu
 * @param {Object} schedule - Harmonogram u≈ºytkownika
 * @param {Array} staleReferences - Lista stalych referencji do usuniƒôcia
 * @param {string} userId - ID u≈ºytkownika
 */
WeeklyScheduleController.prototype._cleanupStaleReferences = async function(schedule, staleReferences, userId) {
  try {
    // Usu≈Ñ stale referencje z recentPlans
    const staleIds = staleReferences.map(ref => ref.planId?.toString());
    schedule.recentPlans = schedule.recentPlans.filter(planRef => 
      !staleIds.includes(planRef.planId?.toString())
    );

    // Zapisz zaktualizowany harmonogram
    await schedule.save();
    
    logInfo(`Usuniƒôto ${staleReferences.length} stalych referencji dla u≈ºytkownika ${userId}`);
  } catch (error) {
    logError(`B≈ÇƒÖd podczas usuwania stalych referencji dla u≈ºytkownika ${userId}`, error);
  }
};

/**
 * Generuje nowy plan tygodniowy (zaczynajƒÖc od tygodnia 1)
 */
WeeklyScheduleController.prototype.generateNewPlan = async function(req, res, next) {
  try {
    const userId = req.user.sub;
    
    logInfo(`Generating new plan for user ${userId} starting from week 1`);

    // Spr√≥buj pobraƒá dane u≈ºytkownika z istniejƒÖcego harmonogramu lub formularza
    let userProfile = {
      name: 'User',
      age: 30,
      experienceLevel: 'beginner',
      mainGoal: 'start_running',
      daysPerWeek: 3
    };
    
    // ZAWSZE pr√≥buj pobraƒá dane z najnowszego formularza
    try {
      const TrainingFormSubmission = require('../models/running-form.model');
      // Znajd≈∫ najnowszy formularz z wype≈Çnionymi dniami treningowymi
      const latestForm = await TrainingFormSubmission.findOne({ 
        userId,
        dniTreningowe: { $exists: true, $ne: [], $ne: null }
      }).sort({ createdAt: -1 });
      
      if (latestForm) {
        const formData = latestForm.toObject();
        logInfo(`=== DEBUG: Pobrano formularz dla u≈ºytkownika ${userId} ===`, {
          formId: latestForm._id,
          createdAt: latestForm.createdAt,
          dniTreningowe: formData.dniTreningowe,
          allFormFields: Object.keys(formData),
          imieNazwisko: formData.imieNazwisko,
          poziomZaawansowania: formData.poziomZaawansowania
        });
        
        const trainingPlanController = require('./training-plan.controller');
        userProfile = trainingPlanController.mapFormToUserProfile(formData);
        logInfo(`Using profile from latest form data for new plan: ${userProfile.name}, dni: ${JSON.stringify(userProfile.dniTreningowe)}`);
      } else {
        // Brak formularza - stw√≥rz podstawowy harmonogram
        logInfo('No form found - creating basic schedule with default profile');
        // Zostaw domy≈õlny userProfile, system stworzy harmonogram automatycznie
      }
    } catch (formError) {
      logError('Error fetching form data for new plan:', formError);
      return res.status(500).json({
        status: 'error',
        error: 'B≈ÇƒÖd podczas pobierania danych formularza',
        details: formError.message
      });
    }

    
    // Walidacja dni treningowych - BEZ fallback√≥w
    const hasTrainingDays = userProfile?.dniTreningowe && userProfile.dniTreningowe.length > 0;
    const hasTrainingDaysEn = userProfile?.trainingDays && userProfile.trainingDays.length > 0;
    
    if (!hasTrainingDays && !hasTrainingDaysEn) {
      logError(`User ${userId} nie ma okre≈õlonych dni treningowych`, {
        userProfile_dniTreningowe: userProfile?.dniTreningowe,
        userProfile_trainingDays: userProfile?.trainingDays
      });
      
      return res.status(400).json({
        status: 'error',
        error: 'Brak dni treningowych. Musisz okre≈õliƒá dni treningowe w swoim profilu aby wygenerowaƒá plan.',
        details: 'Przejd≈∫ do ustawie≈Ñ profilu i wybierz dni treningowe.'
      });
    }

    // Utw√≥rz lub zaktualizuj prawdziwy harmonogram dla nowego planu
    let schedule;
    try {
      const WeeklyPlanSchedule = require('../models/weekly-plan-schedule.model');
      const existingSchedule = await WeeklyPlanSchedule.findOne({ userId });
      
      if (existingSchedule) {
        // Zaktualizuj istniejƒÖcy harmonogram - resetuj do tygodnia 1
        existingSchedule.userProfile = userProfile; // Zaktualizuj profil u≈ºytkownika
        existingSchedule.progressTracking.weekNumber = 1;
        existingSchedule.progressTracking.currentPhase = 'base';
        existingSchedule.progressTracking.totalWeeksDelivered = 0;
        existingSchedule.progressTracking.lastWeeklyDistance = 0;
        existingSchedule.progressTracking.progressionRate = 1.0;
        existingSchedule.recentPlans = []; // Wyczy≈õƒá poprzednie plany
        existingSchedule.isActive = true;
        existingSchedule.nextDeliveryDate = new Date();
        
        schedule = await existingSchedule.save();
        logInfo(`Zresetowano istniejƒÖcy harmonogram u≈ºytkownika ${userId} do tygodnia 1`);
      } else {
        // Utw√≥rz nowy harmonogram
        schedule = new WeeklyPlanSchedule({
          userId: userId,
          userProfile: userProfile,
          progressTracking: {
            weekNumber: 1,
            currentPhase: 'base',
            totalWeeksDelivered: 0,
            lastWeeklyDistance: 0,
            progressionRate: 1.0
          },
          longTermGoal: 'general_fitness',
          deliveryFrequency: 'weekly',
          adaptationSettings: {
            autoAdjust: true
          },
          recentPlans: [],
          isActive: true,
          nextDeliveryDate: new Date(),
          createdAt: new Date()
        });
        
        schedule = await schedule.save();
        logInfo(`Utworzono nowy harmonogram dla u≈ºytkownika ${userId} z tygodniem 1`);
      }
    } catch (scheduleError) {
      logError('B≈ÇƒÖd podczas tworzenia/aktualizacji harmonogramu:', scheduleError);
      throw new AppError('Nie uda≈Ço siƒô przygotowaƒá harmonogramu dla nowego planu', 500);
    }

    logInfo(`Harmonogram przygotowany dla nowego planu`, {
      scheduleId: schedule._id,
      weekNumber: schedule.progressTracking.weekNumber,
      dniTreningowe: schedule.userProfile.dniTreningowe,
      trainingDays: schedule.userProfile.trainingDays
    });

    // Dodaj zadanie do kolejki Redis
    const planData = {
      resetToWeekOne: true
    };
    
    const jobId = await aiJobService.queueWeeklyPlanGeneration(
      userId,
      schedule._id, // U≈ºyj prawdziwego ID harmonogramu
      planData,
      { priority: 4 } // Najwy≈ºszy priorytet dla nowych plan√≥w
    );

    res.json({
      status: 'queued',
      data: {
        jobId,
        weekNumber: 1,
        isNewPlan: true,
        statusUrl: `/api/plans/status/${jobId}`,
        message: 'Nowy plan tygodniowy jest generowany w kolejce od tygodnia 1'
      }
    });
  } catch (error) {
    logError('B≈ÇƒÖd generowania nowego planu', error);
    
    if (error instanceof AppError) {
      return res.status(error.statusCode).json({
        error: error.message
      });
    }
    
    return res.status(500).json({
      error: 'WystƒÖpi≈Ç b≈ÇƒÖd podczas generowania nowego planu'
    });
  }
};

/**
 * Usuwa wszystkie plany tygodniowe u≈ºytkownika (bulk delete)
 */
WeeklyScheduleController.prototype.deleteAllPlans = async function(req, res, next) {
  try {
    const userId = req.user.sub;
    
    logInfo(`Starting bulk delete of all weekly plans for user ${userId}`);

    const result = await this.weeklyPlanDeliveryService.deleteAllPlans(userId);

    logInfo(`Bulk delete completed for user ${userId}: deleted ${result.deletedCount} plans`);

    res.json({
      status: 'success',
      data: {
        message: `Usuniƒôto ${result.deletedCount} plan√≥w tygodniowych`,
        deletedCount: result.deletedCount,
        scheduleReset: result.scheduleReset
      }
    });
  } catch (error) {
    logError('B≈ÇƒÖd podczas bulk delete plan√≥w tygodniowych', error);
    
    if (error instanceof AppError) {
      return res.status(error.statusCode).json({
        error: error.message
      });
    }
    
    return res.status(500).json({
      error: 'WystƒÖpi≈Ç b≈ÇƒÖd podczas usuwania wszystkich plan√≥w'
    });
  }
};

/**
 * Sprawdza status zadania generowania planu w kolejce Redis
 */
WeeklyScheduleController.prototype.getJobStatus = async function(req, res, next) {
  try {
    const { jobId } = req.params;
    const userId = req.user.sub;

    if (!jobId) {
      return res.status(400).json({
        status: 'error',
        error: 'Job ID jest wymagane'
      });
    }

    // Pobierz status zadania z kolejki Redis
    const jobStatus = await aiJobService.getJobStatus(jobId);

    if (!jobStatus) {
      return res.status(404).json({
        status: 'error',
        error: 'Zadanie nie zosta≈Ço znalezione'
      });
    }

    // Sprawd≈∫ czy zadanie nale≈ºy do u≈ºytkownika
    if (jobStatus.data && jobStatus.data.userId !== userId) {
      return res.status(403).json({
        status: 'error',
        error: 'Brak uprawnie≈Ñ do tego zadania'
      });
    }

    // Przygotuj odpowied≈∫ z informacjami o statusie
    const response = {
      status: 'success',
      data: {
        jobId,
        status: jobStatus.status || (jobStatus.finishedOn ? 'completed' : 
                jobStatus.failedReason ? 'failed' : 
                jobStatus.processedOn ? 'processing' : 'waiting'),
        progress: jobStatus.progress || 0,
        createdAt: jobStatus.createdAt ? jobStatus.createdAt.toISOString() : new Date(jobStatus.timestamp || Date.now()).toISOString(),
        message: jobStatus.status === 'completed' ? 'Plan zosta≈Ç wygenerowany' :
                 jobStatus.status === 'failed' ? `B≈ÇƒÖd: ${jobStatus.failedReason || 'Unknown error'}` :
                 jobStatus.status === 'processing' ? 'Plan jest generowany...' : 'Zadanie oczekuje w kolejce',
        result: jobStatus.result || null
      }
    };

    // Dodaj informacje o wygenerowanym planie je≈õli zako≈Ñczone
    if (jobStatus.finishedOn && jobStatus.returnvalue) {
      response.data.result = {
        planId: jobStatus.returnvalue.planId,
        weekNumber: jobStatus.returnvalue.weekNumber
      };
    }

    res.json(response);

  } catch (error) {
    logError('B≈ÇƒÖd podczas sprawdzania statusu zadania', error);
    
    if (error instanceof AppError) {
      return res.status(error.statusCode).json({
        status: 'error',
        error: error.message
      });
    }
    
    return res.status(500).json({
      status: 'error',
      error: 'WystƒÖpi≈Ç b≈ÇƒÖd podczas sprawdzania statusu zadania'
    });
  }
};

/**
 * Debug endpoint to check user schedule status
 */
WeeklyScheduleController.prototype.debugUserSchedule = async function(req, res, next) {
  try {
    const userId = req.user.sub;
    const { checkForm = false } = req.query;
    
    logInfo(`Debug schedule check for user: ${userId}`);
    
    const result = {
      userId,
      timestamp: new Date().toISOString(),
      schedule: null,
      form: null,
      issues: []
    };
    
    // Check for active schedule
    try {
      const WeeklyPlanSchedule = require('../models/weekly-plan-schedule.model');
      result.schedule = await WeeklyPlanSchedule.findOne({
        userId,
        isActive: true
      }).lean();
      
      if (!result.schedule) {
        result.issues.push('No active WeeklyPlanSchedule found');
      } else {
        result.schedule.hasValidProfile = !!(result.schedule.userProfile?.dniTreningowe?.length > 0);
      }
    } catch (error) {
      result.issues.push(`Schedule query error: ${error.message}`);
    }
    
    // Check form data if requested
    if (checkForm) {
      try {
        const TrainingFormSubmission = require('../models/running-form.model');
        result.form = await TrainingFormSubmission.findOne({
          userId,
          dniTreningowe: { $exists: true, $ne: [], $ne: null }
        }).sort({ createdAt: -1 }).lean();
        
        if (!result.form) {
          result.issues.push('No valid form submission with training days found');
        }
        
        // Check for multiple forms
        const allForms = await TrainingFormSubmission.find({ userId }).sort({ createdAt: -1 });
        result.totalForms = allForms.length;
        
        if (allForms.length > 1) {
          result.issues.push(`User has ${allForms.length} form submissions (should have only 1)`);
        }
      } catch (error) {
        result.issues.push(`Form query error: ${error.message}`);
      }
    }
    
    // Determine status
    result.status = result.issues.length === 0 ? 'healthy' : 'needs_attention';
    result.canCreateFallback = !result.schedule && result.form;
    
    res.json({
      status: 'success',
      data: result
    });
    
  } catch (error) {
    logError('Debug schedule check error', error);
    
    return res.status(500).json({
      status: 'error',
      error: 'Debug check failed',
      details: error.message
    });
  }
};

/**
 * Create fallback schedule for user (debug endpoint)
 */
WeeklyScheduleController.prototype.createFallbackSchedule = async function(req, res, next) {
  try {
    const userId = req.user.sub;
    
    logInfo(`Creating fallback schedule for user: ${userId}`);
    
    const schedule = await this.weeklyPlanDeliveryService._createFallbackSchedule(userId);
    
    res.json({
      status: 'success',
      data: {
        message: 'Fallback schedule created successfully',
        scheduleId: schedule._id,
        weekNumber: schedule.progressTracking.weekNumber,
        userProfile: {
          name: schedule.userProfile.name,
          daysPerWeek: schedule.userProfile.daysPerWeek,
          trainingDays: schedule.userProfile.dniTreningowe
        }
      }
    });
    
  } catch (error) {
    logError('Create fallback schedule error', error);
    
    if (error instanceof AppError) {
      return res.status(error.statusCode).json({
        status: 'error',
        error: error.message
      });
    }
    
    return res.status(500).json({
      status: 'error',
      error: 'Failed to create fallback schedule',
      details: error.message
    });
  }
};

/**
 * Server-Sent Events endpoint dla powiadomie≈Ñ w czasie rzeczywistym
 */
WeeklyScheduleController.prototype.getNotifications = async function(req, res, next) {
  try {
    const userId = req.user.sub;

    if (!userId) {
      return res.status(401).json({
        status: 'error',
        error: 'U≈ºytkownik musi byƒá zalogowany'
      });
    }

    logInfo(`SSE connection request from user: ${userId}`);

    // Dodaj po≈ÇƒÖczenie SSE
    sseNotificationService.addConnection(userId, res);

    // Nie wywo≈Çuj res.end() - po≈ÇƒÖczenie powinno pozostaƒá otwarte
    // Express automatycznie obs≈Çu≈ºy zamykanie po≈ÇƒÖczenia

  } catch (error) {
    logError('B≈ÇƒÖd podczas ustanawiania po≈ÇƒÖczenia SSE', error);
    
    if (!res.headersSent) {
      return res.status(500).json({
        status: 'error',
        error: 'WystƒÖpi≈Ç b≈ÇƒÖd podczas ustanawiania po≈ÇƒÖczenia z powiadomieniami'
      });
    }
  }
};

module.exports = new WeeklyScheduleController(); 